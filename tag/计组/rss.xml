<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>雨落新痕のblog • Posts by &#34;计组&#34; tag</title>
        <link>https://mashiro.zone</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Fri, 26 Feb 2021 23:22:06 +0800</pubDate>
        <lastBuildDate>Fri, 26 Feb 2021 23:22:06 +0800</lastBuildDate>
        <category>git</category>
        <category>CTF</category>
        <category>NJUPT</category>
        <category>Github</category>
        <category>Hexo</category>
        <category>博客搭建</category>
        <category>test</category>
        <category>不好，是大佬</category>
        <category>change</category>
        <category>feeling</category>
        <category>misc</category>
        <category>web</category>
        <category>note</category>
        <category>信安数基</category>
        <category>plan</category>
        <category>python</category>
        <category>ctf</category>
        <category>php</category>
        <category>html</category>
        <category>css</category>
        <category>direction</category>
        <category>网络爬虫</category>
        <category>obse</category>
        <category>java</category>
        <category>re</category>
        <category>密码学</category>
        <category>计组</category>
        <item>
            <guid isPermalink="true">https://mashiro.zone/informationsafety/njuptnotes/notes/jizhu/</guid>
            <title>计算机组成与结构</title>
            <link>https://mashiro.zone/informationsafety/njuptnotes/notes/jizhu/</link>
            <category>计组</category>
            <pubDate>Fri, 26 Feb 2021 23:22:06 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;a id=&#34;more&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;究竟什么是计算机&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#究竟什么是计算机&#34;&gt;#&lt;/a&gt; 究竟什么是计算机&lt;/h2&gt;
&lt;p&gt;先看看下面这篇文章&lt;/p&gt;
&lt;h2 id=&#34;图解-你管这破玩意叫计算机&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#图解-你管这破玩意叫计算机&#34;&gt;#&lt;/a&gt; &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZmxhc2hzdW4vcC8xNDQwMTYyMy5odG1s&#34;&gt;     图解 | 你管这破玩意叫计算机？        &lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;我和小宇早恋了，我们家住隔壁。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p3-tt.byteimg.com/origin/pgc-image/b03b747e63a741ae9cf59e8d683182c4?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;一-编码与电路信号的转换&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#一-编码与电路信号的转换&#34;&gt;#&lt;/a&gt; 一、编码与电路 —— 信号的转换&lt;/h2&gt;
&lt;p&gt;晚上父母会把手机没收，但我们还想继续聊天，又不敢发出声音，于是我们想到了这个办法...&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p6-tt.byteimg.com/origin/pgc-image/9d4303d9f89e4720b042da377f6e8f7f?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;我们把所有的中文都用灯泡的亮灭组合来表示，同时约定好每隔一秒读取一次灯泡的状态并记录下来，这是我们的暗号。&lt;/p&gt;
&lt;p&gt;我：亮亮灭灭亮&lt;/p&gt;
&lt;p&gt;喜：灭亮亮灭灭&lt;/p&gt;
&lt;p&gt;欢：亮灭亮灭亮&lt;/p&gt;
&lt;p&gt;你：亮亮亮灭灭&lt;/p&gt;
&lt;p&gt;这样，我们虽然没有了手机，依然可以日以继日地聊天，虽然效率很低，但依然很快乐。&lt;/p&gt;
&lt;p&gt;我和小宇就这样在不经意间，将语言转换成为了灯泡的亮灭组合，这个过程叫做编码。&lt;/p&gt;
&lt;h2 id=&#34;二-门电路信号的关联&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#二-门电路信号的关联&#34;&gt;#&lt;/a&gt; 二、门电路 —— 信号的关联&lt;/h2&gt;
&lt;p&gt;我和小宇就这样一直秘密保持着通话，直到上了大学，父母再也管不了我们用手机了。&lt;/p&gt;
&lt;p&gt;但这么多年的小灯泡通话，使我们总觉得事情没那么简单，于是我们开始了一些新的探索。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p1-tt.byteimg.com/origin/pgc-image/3674c94cc87445279b3ed21fdc5fcace?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;我们增加了一个开关。此时当两个开关同时闭合时，灯泡才会亮。&lt;/p&gt;
&lt;p&gt;这样两个开关与灯泡之间，不再是之前简单的对应关系了，而是有了逻辑。&lt;/p&gt;
&lt;p&gt;开关的断开与闭合分别对应着电路的断开与连通。而小灯泡的不亮与亮，也分别对应着电路的断开与连通。那这两者就可以统一，不再依赖于具体的实物表现了。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p6-tt.byteimg.com/origin/pgc-image/f61654b6c67143bd9b8bc28ed749a16d?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;还有，开关的连通与断开，是主动的。而小灯泡的连通与断开，是被动的，是结果。&lt;/p&gt;
&lt;p&gt;我们把开关这里的连通与断开称为输入端，把灯泡的连通与断开称为输出端，并且将整个电路都封装在一个图形里，可以得到如下抽象：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p1-tt.byteimg.com/origin/pgc-image/5308c384af66460e96ee7eb75cb94bdc?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;我们决定把这种电路叫做门电路， 上面这个叫与门。&lt;/p&gt;
&lt;p&gt;为了今后更为抽象的探索，我们将电路连通表示为数字 1，电路断开表示为数字 0。&lt;/p&gt;
&lt;p&gt;我们将这种表示方式称为二进制。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;输入 A&lt;/th&gt;
&lt;th&gt;输入 B&lt;/th&gt;
&lt;th&gt;输出&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;![图解&lt;/td&gt;
&lt;td&gt;你管这破玩意叫计算机？](&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9wMy10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzlkODkzYTBiOTRkMDQwYTRiNjE4NTdhYzg0Mzk4MzllP2Zyb209cGM=&#34;&gt;https://p3-tt.byteimg.com/origin/pgc-image/9d893a0b94d040a4b61857ac8439839e?from=pc&lt;/span&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;慢慢地，我们发现了越来越多的玩法。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p6-tt.byteimg.com/origin/pgc-image/f4938c4bfadd427898d739b523de32be?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;上面这种电路，我把他抽象成如下门电路形状，叫做或门。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p3-tt.byteimg.com/origin/pgc-image/2b3c36a6522d4633b7762edde1c588a0?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;之后便一发不可收拾，我和小宇设计了越来越多的门电路，我们发现，只要是我们能想到的逻辑关系，都可以设计成对应的门电路。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p1-tt.byteimg.com/origin/pgc-image/384e719b58254e55bb092e9493dc7421?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;三-加法器信号的计算&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#三-加法器信号的计算&#34;&gt;#&lt;/a&gt; 三、加法器 —— 信号的计算&lt;/h2&gt;
&lt;p&gt;十进制数可以转换成二进制数，而二进制数又可以对应到门电路的输入端与输出端。&lt;/p&gt;
&lt;p&gt;于是我和小宇有了一个大胆的想法，能不能设计一个计算加法的电路呢？&lt;/p&gt;
&lt;p&gt;我们首先从最简单的一位二进制数相加开始：&lt;/p&gt;
&lt;p&gt;0+0=0；0+1=1；1+0=1；1+1=10&lt;/p&gt;
&lt;p&gt;变成一张表格如下&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;加数 A&lt;/th&gt;
&lt;th&gt;加数 B&lt;/th&gt;
&lt;th&gt;加和输出&lt;/th&gt;
&lt;th&gt;进位输出&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;即我们需要设计出一种电路，可以达到表中的输入与输出效果。&lt;/p&gt;
&lt;p&gt;经过不懈努力，终于发现这个电路可以由异或门和与门两个门电路组成。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p6-tt.byteimg.com/origin/pgc-image/2be81616637145c695c751d9921e8815?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这个装置实现了二进制的一位加法，但它并不完美，因为只考虑了这两个数的进位输出，但没有考虑上一位的进位，所以只能叫半加器。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p3-tt.byteimg.com/origin/pgc-image/a0f2dad9da0048b5894cefcf140d4440?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;如果将前一个进位考虑进来，只需再多一个半加器，并且拼接一个或门即可。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p1-tt.byteimg.com/origin/pgc-image/3e00029bb4a548a68dc44ce8c3560e86?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;此时我们已经建立好了一个完美的一位加法器，并自豪地称之为全加器。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p3-tt.byteimg.com/origin/pgc-image/961f8e2755e14a5793bdb69881ba7511?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;全加器做出来之后，无论多少位的加法器就都可以做出来了，只需将全加器逐个拼起来即可。我们尝试做一个八位加法器。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p6-tt.byteimg.com/origin/pgc-image/331a30cb576a4811a1a67aedb8c079cc?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;OK，大功告成，有了加法器，理论上就可以实现任何的数学运算了。&lt;/p&gt;
&lt;p&gt;因为我们知道乘法可以转换成加法，除法可以转换成减法，而减法又可以转换成补码的加法。现在我们可以自豪地称这个部件为，算术逻辑单元 ALU。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p3-tt.byteimg.com/origin/pgc-image/c59d28c946cd47b880daa53d47350b47?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;四-时钟信号的震荡&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#四-时钟信号的震荡&#34;&gt;#&lt;/a&gt; 四、时钟 —— 信号的震荡&lt;/h2&gt;
&lt;p&gt;我和小宇都非常高兴，终于用电路的方式实现了计算功能。&lt;/p&gt;
&lt;p&gt;但慢慢的觉得没什么意思了，于是我们又突发奇想，设计了如下诡异的电路。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p1-tt.byteimg.com/origin/pgc-image/8fbd3c9b03f54fa5b7a367a62a55da52?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;当闭合开关 A 时，整个电路联通，开关 B 将会被吸下来，整个电路断开，电磁铁失去磁性，开关 B 又会弹上去，此时电路又联通，开关 B 又被吸下来。&lt;/p&gt;
&lt;p&gt;就这样，开关 B 不断地快速地在开和闭之间循环进行，而我们始终没有去干预这个电路，因此该电路有了自反馈的特性。&lt;/p&gt;
&lt;p&gt;由于开关 B 的来回震荡，我们将这种电路称为振荡器，由于它可以产生不断变化的电信号，就像时钟一样不停且规律地跑着，我们将这个装置又称为时钟。它所产生的交替的电信号称为时钟信号。&lt;/p&gt;
&lt;h2 id=&#34;五-ram保存信号&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#五-ram保存信号&#34;&gt;#&lt;/a&gt; 五、RAM—— 保存信号&lt;/h2&gt;
&lt;p&gt;虽然有了加法器，但是输入的数字从哪里来？能不能先保存在某个地方呢？&lt;/p&gt;
&lt;p&gt;我和小宇经过多次实验，发明了一个非常复杂的电路：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p6-tt.byteimg.com/origin/pgc-image/15f2fd8a089742d394b1605acef992d1?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;如果输入端为 1，改变 &amp;quot;某控制端&amp;quot; 信号（信号由 0 变化到 1 这个瞬间），则输出端变为 1，之后输出端仍然保持（存储）着刚刚的 1。&lt;/p&gt;
&lt;p&gt;如果输入端为 0，改变 &amp;quot;某控制端&amp;quot; 信号，则输出端变为 0，之后输出端仍然保持（存储）着刚刚的 0。&lt;/p&gt;
&lt;p&gt;如果想不明白也没关系，只要记住这个电路的设计，实现了一位的存储功能！我们叫它 1 位锁存器。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p3-tt.byteimg.com/origin/pgc-image/e17f9177a1d7442598941926c82efe3f?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;然后我们把多个锁存器组合起来，再加上一些 3-8 译码器，8-1 选择器等电路，就可以实现一个能保存 8 位二进制的存储器，并且可以随机地读写它， 我们把它叫做 RAM，简称为内存。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p6-tt.byteimg.com/origin/pgc-image/400a0a4909dd474fa421ad919e0aac70?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这个组件通过再次组合，可以形成 N × M 的 RAM 阵列。比如我们可以表示一个 1024 * 8 的 RAM 阵列。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p1-tt.byteimg.com/origin/pgc-image/3c79d7bf4fc946328e17a34f570f5b49?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这表示存储容量为 1024 个单位，每个单位占 8 位。&lt;/p&gt;
&lt;p&gt;为了更方便地表示，我们规定 1024 = 1K，8 位 = 1 字节（8 bit = 1 byte），那么我们就可以说，这个 RAM 的存储容量为 1K 个单位，每个单位占 1B。或者说，地址空间为 1K，存储容量是 1KB。&lt;/p&gt;
&lt;p&gt;此时这个 RAM 模块已经近乎完美了，我们甚至可以单独对其进行使用，将数据存入某个地址，将某个地址中的数据读出。&lt;/p&gt;
&lt;p&gt;怎么方便人操作呢？只需要将地址输入、数据输入、写操作端分别接入一个控制面板，由开关来控制这些信号的输入是 1 还是 0 即可，然后再将数据输出接入一些灯泡方便观察，这样一个单独的可以手动操作的存储装置，就搞定啦。（下图中有彩蛋～）&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p6-tt.byteimg.com/origin/pgc-image/b51aaf1d8008469db5bf89c6f2e5b17e?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;有了可读写的内存，我们就可以事先把几个数字存储内存中了，接下来，我们能否让算术逻辑单元 ALU 自动地读取这个数字，进行加法运算呢？&lt;/p&gt;
&lt;h2 id=&#34;六-程序自动化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#六-程序自动化&#34;&gt;#&lt;/a&gt; 六、程序 —— 自动化&lt;/h2&gt;
&lt;p&gt;我们先引入一个新的组件，10 位计数器，这里的 Clk 就接入我们在第四部分讲的时钟信号，Clr 是清零端，具体效果下面动图一目了然。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p3-tt.byteimg.com/origin/pgc-image/9248fe21ffde4be7b07f66a51ebc226b?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;计数器的输出就是 0，1，2，3，4，5，可以当作内存中的地址。&lt;/p&gt;
&lt;p&gt;我们把这个计数器，以及上面讲的 ALU 与 RAM 全部连在一起，尝试实现一个可以累积求和的装置。&lt;/p&gt;
&lt;p&gt;我们想计算的是 1+2+3+4+5+6+7, 这个自动化的计算器是这么运行的&lt;/p&gt;
&lt;p&gt;1、用控制面板在 RAM 的地址 0~6 处存上 1~7 这几个数字的，在上一节已经实现了。&lt;/p&gt;
&lt;p&gt;2、当计数器的值是 0 时，数据 1 被输出到加法器进行计算，此时加法器 A=1，B=0，计算结果为 1，但记住锁存器存储的是上一次的加法器输出 0，这次的计算结果要等下一次锁存器遇到上升沿信号。&lt;/p&gt;
&lt;p&gt;3、当计数器的值是 1 时， 数据 2 被输入到加法器，此时锁存器存储了上一次的计算结果 1，并将这个 1 输出给小灯泡，并同时回传到加法器的 B，所以此时加法器 A=2，B=1，计算结果为 3&lt;/p&gt;
&lt;p&gt;4、当计数器的值是 3 时，以此类推，请看下图&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p3-tt.byteimg.com/origin/pgc-image/bac0cd132b064627a2eee954c567d1cc?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;我们将累加求和这个过程自动化了！之后如果想计算累加和，只需要用控制面板事先在内存里存好数据就可以了！是不是很方便？&lt;/p&gt;
&lt;h2 id=&#34;七-程序指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#七-程序指令&#34;&gt;#&lt;/a&gt; 七、程序指令&lt;/h2&gt;
&lt;p&gt;我们还想要更多的自动化！&lt;/p&gt;
&lt;p&gt;现在这个装置，只能无脑地将 RAM 中的数据从头到尾一直累加下去，无法选择加哪个不加哪个，也无法选择什么时候停止。&lt;/p&gt;
&lt;p&gt;比如我们 RAM 中的数据是这样的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;地址（16 进制）&lt;/th&gt;
&lt;th&gt;数据（10 进制）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x02&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x03&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x04&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x05&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们只想让 RAM 蓝色地址处的数据进行累加，其他地方的数据忽略，并且到 RAM 0x05 处就停止，该怎么做呢？&lt;/p&gt;
&lt;p&gt;我们可以再增加一个 RAM，这个 RAM 里存放的数据，表示 &amp;quot;指令&amp;quot; 的含义！&lt;/p&gt;
&lt;p&gt;我们先发明三种指令。&lt;/p&gt;
&lt;p&gt;add：把 RAM 这个位置处的值进行累加&lt;/p&gt;
&lt;p&gt;nop：忽略此处的值（也就是什么都不做）&lt;/p&gt;
&lt;p&gt;halt：停止（禁止计数器的值加一）&lt;/p&gt;
&lt;p&gt;那么要想达到上述功能，相应的这个指令 RAM 中的数据应该是这样的。&lt;/p&gt;
&lt;p&gt;注意：下面指令 RAM 的地址和上面数据 RAM 的地址之间有一一对应关系！&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;地址 （16 进制）&lt;/th&gt;
&lt;th&gt;指令 RAM 的值&lt;/th&gt;
&lt;th&gt;指令含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;nop&lt;/td&gt;
&lt;td&gt;什么都不做&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;add&lt;/td&gt;
&lt;td&gt;累加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x02&lt;/td&gt;
&lt;td&gt;nop&lt;/td&gt;
&lt;td&gt;什么都不做&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x03&lt;/td&gt;
&lt;td&gt;add&lt;/td&gt;
&lt;td&gt;累加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x04&lt;/td&gt;
&lt;td&gt;add&lt;/td&gt;
&lt;td&gt;累加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x05&lt;/td&gt;
&lt;td&gt;halt&lt;/td&gt;
&lt;td&gt;停止&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们需要引入一个控制单元，放在如下位置。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p6-tt.byteimg.com/origin/pgc-image/4c492a3911a842f29c5b5c6f5378d526?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;遇到 nop 指令 (0x00)，那输出就将锁存器的 W 位禁止，不允许锁存器写操作，这样累加结果就不会录入。&lt;/p&gt;
&lt;p&gt;再比如遇到输入为 halt 指令 (0x05)，就将计数器的 EN 位禁止，不允许计数器 +1，这样就达到了停止的效果。&lt;/p&gt;
&lt;p&gt;此时再让时钟信号震荡起来，就可以达到有选择地求和过程，并且在指定位置悬停。那现在我们就让时钟信号震动起来，看看这个过程吧。（此处只留关键组件）&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://p3-tt.byteimg.com/origin/pgc-image/00efef7e89a1450e94cb1dd9cb000775?from=pc&#34; alt=&#34;图解 | 你管这破玩意叫计算机？&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这个控制单元该怎么实现呢？我们知道，只要给出输入，给出输出，任何组件都可以造出来。本文就不再展开了。&lt;/p&gt;
&lt;p&gt;有了三个指令，我们知道了通过指令这种方式，配合各种复杂的控制器，即可实现将所有操作统统自动化。&lt;/p&gt;
&lt;p&gt;接下来我们需要做的，就是设计控制器，以及约定好一大堆指令，使得通过这一大堆指令的排列组合，可以实现任何自动化的计算操作。&lt;/p&gt;
&lt;p&gt;我们将设计好的一大堆指令&lt;/p&gt;
&lt;p&gt;称作指令集&lt;/p&gt;
&lt;p&gt;我们将指令排列组合后可以实现的功能&lt;/p&gt;
&lt;p&gt;称作程序&lt;/p&gt;
&lt;p&gt;我们将指令的排列组合这个过程&lt;/p&gt;
&lt;p&gt;称作编程&lt;/p&gt;
&lt;p&gt;我们将排列组合这些指令的人&lt;/p&gt;
&lt;p&gt;称作程序员&lt;/p&gt;
&lt;p&gt;而我们将承载这一切的装置，叫做什么呢？&lt;/p&gt;
&lt;p&gt;没错，这个破玩意，就是&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计&lt;/strong&gt;算机&lt;/p&gt;
&lt;p&gt;以上均为转载&lt;/p&gt;
&lt;h2 id=&#34;文章摘取&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#文章摘取&#34;&gt;#&lt;/a&gt; 文章摘取&lt;/h2&gt;
&lt;h3 id=&#34;什么是arm架构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#什么是arm架构&#34;&gt;#&lt;/a&gt; 什么是 ARM 架构&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;整部主机的重点在于中央处理器 （Central Processing Unit, CPU），CPU 为一个具有特定功&lt;br /&gt;
能的芯片， 里头含有微指令集，如果你想要让主机进行什么特异的功能，就得要参考这颗&lt;br /&gt;
 CPU 是否有相关内置的微指令集才可以。 由于 CPU 的工作主要在于管理与运算，因此在&lt;br /&gt;
 CPU 内又可分为两个主要的单元，分别是： 算数逻辑单元与控制单元。[3] 其中算数逻辑单&lt;br /&gt;
元主要负责程序运算与逻辑判断，控制单元则主要在协调各周边元件与各单元间的工作。&lt;br /&gt;
既然 CPU 的重点是在进行运算与判断，那么要被运算与判断的数据是从哪里来的？ CPU 读&lt;br /&gt;
取的数据都是从内存来的！ 内存内的数据则是从输入单元所传输进来！而 CPU 处理完毕的&lt;br /&gt;
数据也必须要先写回内存中，最后数据才从内存传输到输出单元。&lt;/p&gt;
&lt;p&gt;通常将内存容量加大就可以获得相当好的成效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;ARM 架构&lt;/p&gt;
&lt;p&gt;精简指令集 （Reduced Instruction Set Computer, RISC）：[5]&lt;br /&gt;
 这种 CPU 的设计中，微指令集较为精简，每个指令的执行时间都很短，完成的动作也很单&lt;br /&gt;
纯，指令的执行性能较佳； 但是若要做复杂的事情，就要由多个指令来完成。常见的 RISC&lt;br /&gt;
 微指令集 CPU 主要例如甲骨文 （Oracle） 公司的 SPARC 系列、 IBM 公司的 Power&lt;br /&gt;
Architecture （包括 PowerPC） 系列、与安谋公司 （ARM Holdings） 的 ARM CPU 系列&lt;br /&gt;
等。&lt;/p&gt;
&lt;p&gt;在应用方面，SPARC CPU 的电脑常用于学术领域的大型工作站中，包括银行金融体系的主&lt;br /&gt;
要服务器也都有这类的电脑架构； 至于 PowerPC 架构的应用上，例如索尼（Sony）公司出产&lt;br /&gt;
的 Play Station 3（PS3）就是使用 PowerPC 架构的 Cell 处理器； 那安谋的 ARM 呢？你常使&lt;br /&gt;
用的各厂牌手机、PDA、导航系统、网络设备（交换器、路由器等）等，几乎都是使用 ARM&lt;br /&gt;
 架构的 CPU 喔！ 老实说，目前世界上使用范围最广的 CPU 可能就是 ARM 这种架构的呢！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;什么是x86_64架构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#什么是x86_64架构&#34;&gt;#&lt;/a&gt; 什么是 x86_64 架构&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;复杂指令集（Complex Instruction Set Computer, CISC）：[7]&lt;br /&gt;
 与 RISC 不同的，CISC 在微指令集的每个小指令可以执行一些较低阶的硬件操作，指令数目多&lt;br /&gt;
而且复杂， 每条指令的长度并不相同。因为指令执行较为复杂所以每条指令花费的时间较&lt;br /&gt;
长， 但每条个别指令可以处理的工作较为丰富。常见的 CISC 微指令集 CPU 主要有 AMD、&lt;br /&gt;
Intel、VIA 等的 x86 架构的 CPU。&lt;br /&gt;
由于 AMD、Intel、VIA 所开发出来的 x86 架构 CPU 被大量使用于个人电脑（Personal&lt;br /&gt;
computer）用途上面， 因此，个人电脑常被称为 x86 架构的电脑！那为何称为 x86 架构 [8] 呢？&lt;br /&gt;
这是因为最早的那颗 Intel 发展出来的 CPU 代号称为 8086，后来依此架构又开发出 80286,&lt;br /&gt;
80386...， 因此这种架构的 CPU 就被称为 x86 架构了。&lt;br /&gt;
在 2003 年以前由 Intel 所开发的 x86 架构 CPU 由 8 位升级到 16、32 位，后来 AMD 依此架构修改新&lt;br /&gt;
一代的 CPU 为 64 位， 为了区别两者的差异，因此 64 位的个人电脑 CPU 又被统称为 x86_64 的&lt;br /&gt;
架构喔！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;最重要的是脑子&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#最重要的是脑子&#34;&gt;#&lt;/a&gt; 最重要的是脑子&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://cdn.jsdelivr.net/gh/yuanoes/imagehost@main/pic/image-20210228222805668.png&#34; alt=&#34;image-20210228222805668&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;CPU = 脑袋瓜子：每个人会作的事情都不一样（微指令集的差异），但主要都是通过脑袋&lt;br /&gt;
瓜子来进行判断与控制身体各部分的活动；&lt;/li&gt;
&lt;li&gt;内存 = 脑袋中放置正在被思考的数据的区块：在实际活动过程中，我们的脑袋瓜子需要有&lt;br /&gt;
外界刺激的数据 （例如光线、环境、语言等） 来分析，那这些互动数据暂时存放的地方&lt;br /&gt;
就是内存，主要是用来提供给脑袋瓜子判断用的信息。&lt;/li&gt;
&lt;li&gt;硬盘 = 脑袋中放置回忆的记忆区块：跟刚刚的内存不同，内存是提供脑袋目前要思考与处&lt;br /&gt;
理的信息，但是有些生活琐事或其他没有要立刻处理的事情， 就当成回忆先放置到脑袋&lt;br /&gt;
的记忆深处吧！那就是硬盘！主要目的是将重要的数据记录起来，以便未来将这些重要&lt;br /&gt;
的经验再次的使用；&lt;/li&gt;
&lt;li&gt;主板 = 神经系统：好像人类的神经一样，将所有重要的元件连接起来，包括手脚的活动都&lt;br /&gt;
是脑袋瓜子发布命令后， 通过神经（主板）传导给手脚来进行活动啊！&lt;br /&gt;
各项周边设备 = 人体与外界沟通的手、脚、皮肤、眼睛等：就好像手脚一般，是人体与外&lt;br /&gt;
互动的重要关键！&lt;/li&gt;
&lt;li&gt;显卡 = 脑袋中的影像：将来自眼睛的刺激转成影像后在脑袋中呈现，所以显卡所产生的数&lt;br /&gt;
据来源也是 CPU 控制的。&lt;/li&gt;
&lt;li&gt;电源供应器 （Power）= 心脏：所有的元件要能运行得要有足够的电力供给才行！这电力&lt;br /&gt;
供给就好像心脏一样，如果心脏不够力， 那么全身也就无法动弹的！心脏不稳定呢？那&lt;br /&gt;
你的身体当然可能断断续续的～不稳定！&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;计算机常用的单位容量速度&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#计算机常用的单位容量速度&#34;&gt;#&lt;/a&gt; 计算机常用的单位（容量，速度）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;容量单位&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;bit: 0/1 代表 1 位&lt;/p&gt;
&lt;p&gt;byte：代表 1 字节 = 8 位&lt;/p&gt;
&lt;p&gt;k：1024byte&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;速度单位&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CPU 的运算速度常使用 MHz 或者是 GHz 之类的单位，这个 Hz 其实就是秒分之一。而在网&lt;br /&gt;
络传输方面，由于网络使用的是 bit 为单位，因此网络常使用的单位为 Mbps 是 Mbits per&lt;br /&gt;
second，亦即是每秒多少 Mbit。举例来说，大家常听到的 20M/5M 光世代传输速度，如果转&lt;br /&gt;
成文件大小的 Byte 时，其实理论最大传输值为：每秒 2.5MByte/ 每秒 625KByte 的下载 / 上传&lt;br /&gt;
速度喔！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;intel芯片架构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#intel芯片架构&#34;&gt;#&lt;/a&gt; Intel 芯片架构&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;由于主板是链接各元件的一个重要项目，因此在主板上面沟通各部元件的芯片组设计优劣，&lt;br /&gt;
就会影响性能不少喔！早期的芯片组通常分为两个桥接器来控制各元件的沟通， 分别是：&lt;br /&gt;
（1）北桥：负责链接速度较快的 CPU、内存与显卡接口等元件；（2）南桥：负责连接速度&lt;br /&gt;
较慢的设备接口， 包括硬盘、USB、网卡等等。（芯片组的南北桥与三国的大小乔没有关系&lt;br /&gt;
 @_@）。不过由于北桥最重要的就是 CPU 与内存之间的桥接，因此目前的主流架构中， 大&lt;br /&gt;
多将北桥内存控制器整合到 CPU 封装当中了。所以上图你只会看到 CPU 而没有看到以往的&lt;br /&gt;
北桥芯片喔！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;cpu的频率&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cpu的频率&#34;&gt;#&lt;/a&gt; cpu 的频率&lt;/h3&gt;
&lt;p&gt;我们前面谈到 CPU 内部含有微指令集，不同的微指令集会导致 CPU 工作效率的优劣。除了这&lt;br /&gt;
点之外， CPU 性能的比较还有什么呢？那就是 CPU 的频率了！什么是频率呢？简单的说， 频&lt;br /&gt;
率就是 CPU 每秒钟可以进行的工作次数。 所以频率越高表示这颗 CPU 单位时间内可以作更多&lt;br /&gt;
的事情。举例来说，Intel 的 i7-4790 CPU 频率为 3.6GHz， 表示这颗 CPU 在一秒内可以进行&lt;br /&gt;
 3.6x109 次工作，每次工作都可以进行少数的指令运行之意。&lt;br /&gt;
Tips 注意，不同的 CPU 之间不能单纯的以频率来判断运算性能喔！这是因为每颗 CPU 的微指&lt;br /&gt;
令集不相同，架构也不见得一样，可使用的第二层高速缓存及其计算机制可能也不同， 加上&lt;br /&gt;
每次频率能够进行的工作指令数也不同！所以，频率目前仅能用来比较同款 CPU 的速度&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
